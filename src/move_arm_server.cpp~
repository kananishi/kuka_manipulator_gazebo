#include "ros/ros.h"
#include "ros/time.h"
#include "std_msgs/Float64.h"
#include "manipulator_gazebo/MoveArm.h"
#include "sensor_msgs/JointState.h"
#include "math.h"

using namespace std_msgs;

//  global parameters
const int	N = 200;
double		dt;
double		current_joint_states[3];

// global ros objects
ros::NodeHandle n;
ros::Publisher joints_pub_;


void calc_cartezian_trajectory(double CT[3][N] , Float64 desX , Float64 desY , Float64 desZ , double initial_pose_end_effector[3])
{
	double trajectory_length;
	double trajectory_dir_vec[3];
	double v_max;
	double duration = dt * N;
	double t=0; //incremental running time
	double step_size[N];
	int i=1;

	trajectory_length = sqrt( pow(desX - initial_pose_end_effector[0],2) + pow(desY - initial_pose_end_effector[1],2) + pow(desZ - initial_pose_end_effector[2],2));

	trajectory_dir_vec[0] = (desX - initial_pose_end_effector[0]) / trajectory_length;
	trajectory_dir_vec[1] = (desY - initial_pose_end_effector[1]) / trajectory_length;
	trajectory_dir_vec[2] = (desZ - initial_pose_end_effector[2]) / trajectory_length;

	v_max = 4/3 * trajectory_length/duration;

	//the trajectory divided to three different parts. 
	//1st part is quarter of the duration time that have acceleration.
	//2nd part is two quarter of the duration time with steady velocity.
	//3rd part is another quarter of the duration time that have deceleration.
	step_size[0] = 2 * v_max / duration * pow(dt,2);
	t+=dt;
	while (t < duration / 4) //1st part
	{
		step_size[i] = step_size[i-1] + (4 * v_max /duration) * t * dt + 2 * v_max /duration * pow(dt,2);
		i++;
		t+=dt;
	}
	while (t < 3 * duration / 4) //2nd part
	{
		step_size[i] = step_size[i-1] + v_max * dt;
		i++;
		t+=dt;
	}
	while (t <= duration) //3rd part
	{
		step_size[i] = step_size[i-1] + (4 * v_max - 4 / duration * v_max * t) * dt - 2 * v_max / duration * pow(dt,2);
		i++;
		t+=dt;
	}

	//calculating the cartezian trajectory
	for (i=0; i<3; i++)
	{
		CT[i][0] = step_size[0] * trajectory_dir_vec[i] + initial_pose_end_effector[i];
	}
	for (i=1; i<N ; i++)
	{
		for (int j=0; j<3 ; j++)
		{
			CT[j][i] = step_size[i] * trajectory_dir_vec[j] + CT[j][i-1];
		}
	}
}

void calc_joint_trajectory(double CT[3][N] , double JT[3][N])
{
	double jacobian_inverse[3][3];
	double th1, th2, th3;

	th1 = current_joint_states[0];
	th2 = current_joint_states[1];
	th3 = current_joint_states[2];
	//set the initial joint states into JT
	for (int i=0; i<3 ;i++)
	{
		JT[i][0] = current_joint_states[i];
	}

	for (int i=0; i<N; i++)
	{
		//calculating current inverse jacobian
		jacobian_inverse[0][0] = cos(th1)/1000 - (6247*sin(th1))/100000 - (1253*cos(th2)*sin(th1))/100000 - (73*sin(th1)*sin(th2))/200 - (243*cos(th2)*sin(th1)*sin(th3))/500 - (243*cos(th3)*sin(th1)*sin(th2))/500 - (9*sin(th1)*sin(th2)*sin(th3))/100 + (9*cos(th2)*cos(th3)*sin(th1))/100;
		jacobian_inverse[0][1] = (cos(th1)*(48600*cos(th2 + th3) + 9000*sin(th2 + th3) + 36500*cos(th2) - 1253*sin(th2)))/100000;
		jacobian_inverse[0][2] = (9*cos(th1)*(27*cos(th2 + th3) + 5*sin(th2 + th3)))/500;
		jacobian_inverse[1][0] = (6247*cos(th1))/100000 + sin(th1)/1000 + (1253*cos(th1)*cos(th2))/100000 + (73*cos(th1)*sin(th2))/200 + (9*cos(th1)*sin(th2)*sin(th3))/100 - (9*cos(th1)*cos(th2)*cos(th3))/100 + (243*cos(th1)*cos(th2)*sin(th3))/500 + (243*cos(th1)*cos(th3)*sin(th2))/500;
		jacobian_inverse[1][1] = (sin(th1)*(48600*cos(th2 + th3) + 9000*sin(th2 + th3) + 36500*cos(th2) - 1253*sin(th2)))/100000;
		jacobian_inverse[1][2] = (9*sin(th1)*(27*cos(th2 + th3) + 5*sin(th2 + th3)))/500;
		jacobian_inverse[2][0] = 0;
		jacobian_inverse[2][1] = (9*cos(th2 + th3))/100 - (243*sin(th2 + th3))/500 - (1253*cos(th2))/100000 - (73*sin(th2))/200;
		jacobian_inverse[2][2] = (9*cos(th2 + th3))/100 - (243*sin(th2 + th3))/500;

		for (int j=0; j<3; j++) 
		{
			if (i == 0)
			{
				for (int k=0; k<3; k++)
				{
				JT[j][i] += jacobian_inverse[j][k] * CT[k][i]; 
				}
			}
			else if (i != 0)
			{
				JT[j][i] = JT[j][i-1];
				for (int k=0; k<3; k++)
				{
				JT[j][i] += jacobian_inverse[j][k] * (CT[k][i] - CT[k][i-1]); 
				}
			}
		}

		//updating th1,th2,th3 for the upcoming recalaulte of the inverse jacobian
		th1 = JT[0][i];
		th2 = JT[1][i];
		th3 = JT[2][i];
	}
}

void calc_cartezian_pose_end_effector(double cjs[3])
{
	double th1, th2, th3;

	th1 = current_joint_states[0];
	th2 = current_joint_states[1];
	th3 = current_joint_states[2];

	cjs[0] = (6247*cos(th1))/100000 + sin(th1)/1000 + (1253*cos(th1)*cos(th2))/100000 + (73*cos(th1)*sin(th2))/200 + (9*cos(th1)*sin(th2)*sin(th3))/100 - (9*cos(th1)*cos(th2)*cos(th3))/100 + (243*cos(th1)*cos(th2)*sin(th3))/500 + (243*cos(th1)*cos(th3)*sin(th2))/500;
	cjs[1] = (6247*sin(th1))/100000 - cos(th1)/1000 + (1253*cos(th2)*sin(th1))/100000 + (73*sin(th1)*sin(th2))/200 + (243*cos(th2)*sin(th1)*sin(th3))/500 + (243*cos(th3)*sin(th1)*sin(th2))/500 + (9*sin(th1)*sin(th2)*sin(th3))/100 - (9*cos(th2)*cos(th3)*sin(th1))/100;
	cjs[2] = (243*cos(th2 + th3))/500 + (9*sin(th2 + th3))/100 + (73*cos(th2))/200 - (1253*sin(th2))/100000 + 169/500;

}

void control_joint_trajectory(double JT[3][N])
{
	double msg;
	for (int i=0; i<N; i++)
	{
		msg = JT[0][i];
		n.advertise<std_msgs::Float64>("/manipulator/link_1_controller/command", 1000);
		chatter_pub.publish(msg);
		msg = JT[1][i];
		n.advertise<std_msgs::Float64>("/manipulator/link_2_controller/command", 1000);
		chatter_pub.publish(msg);
		msg = JT[2][i];
		n.advertise<std_msgs::Float64>("/manipulator/link_3_controller/command", 1000);
		chatter_pub.publish(msg);
		ros::Duration(dt).sleep();
	}
}

bool move_arm(manipulator_gazebo::MoveArm::Request  &req,
              manipulator_gazebo::MoveArm::Response &res)
{
	double cartezian_trajectory[3][N];
	double joint_trajectory[3][N];
	double initial_joint_states[3];
	double initial_pose_end_effector[3];

	Float64 desX		= req.desired_xyz[0];
	Float64 desY		= req.desired_xyz[1];
	Float64 desZ		= req.desired_xyz[2];

	dt					= req.duration.data/N;

	calc_cartezian_pose_end_effector(initial_pose_end_effector);

	ROS_INFO("current cartezian position [ x y z ] : %.3f  %.3f  %.3f  ",initial_pose_end_effector[0],
																	  	 initial_pose_end_effector[1],
																		 initial_pose_end_effector[2]);
	ROS_INFO("I got:");
	ROS_INFO("desired [ x y z ]          = [ %.3f %.3f %.3f ]",desX.data,desY.data,desZ.data);
	ROS_INFO("desired iteration time     = %f",dt);

	ROS_INFO("Calculating cartezian trajectory");
	calc_cartezian_trajectory(cartezian_trajectory , desX ,desY , desZ , initial_pose_end_effector);

	ROS_INFO("Calculating joint trajectory");
	calc_joint_trajectory(cartezian_trajectory,joint_trajectory);

	ROS_INFO("Sending joint trajectory and controlling");
    control_joint_trajectory(joint_trajectory);

	res.success.data = "True";

	return true;
}

void jointCallback(const sensor_msgs::JointState &msg)
{
	current_joint_states[0] = msg.position[0];
	current_joint_states[1] = msg.position[1];
	current_joint_states[2] = msg.position[2];
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, "move_arm_server");

  ros::ServiceServer service = n.advertiseService("move_arm", move_arm);
  ros::Subscriber joints_sub_ = n.subscribe("/manipulator/joint_states", 1000, jointCallback );


  ROS_INFO("Ready for commands:");
  ros::spin();

  return 0;
}
